{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/11/hello-world/"},{"title":"Hexo를 이용해서 github.io blog 만들기","text":"Hexo를 이용해서 github.io blog 만들기1234Hexo는 무엇인가요? (참조 https://hexo.io/ko/docs/)Hexo는 빠르고 간단하고 파워풀한 블로그 프레임워크입니다. Markdown(또는 다른 언어)을 사용하여 포스트를 작성하면 Hexo는 금세 멋진 테마를 가미해서 정적인 파일을 생성해 드립니다. 구름 사이트 접속 이후 계정을 생성한다. (참조 https://ide.goorm.io/?plan=ZnJlZQ== ) 새로운 컨테이너를 생성클릭한다. 이름, 설명을 등록하고 소프트웨어 스택은 Node.js를 선택한다. 컨테이서 생성을 클릭한다. 새로운 컨테이너가 생성되면 새로운 구름IDE의 페이지가 실행된다. 구름IDE의 좌측은 폴더가 아랫쪽은 터미널이 실행된다. 구름IDE의 터미널에 Hexo를 설치하기 위해서 아래의 명령을 실행한다. -g global 1npm install hexo-cli -g Hexo를 초기화한다. hexoblog는 구름IDE의 좌측에 생성되는 폴더이름이다. 1hexo init hexoblog 현재 디렉토리 확인 이후 4번에서 생성한 폴더로 이동한다. 1234root@goorm:/workspace/blog# pwd/workspace/blogroot@goorm:/workspace/blog# cd hexoblog/root@goorm:/workspace/blog/hexoblog# 터미널에 npm install을 명령어를 실행한다. 1npm install themes를 설치한다. 12적당한 Themes의 제목을 클릭하면 github 페이지로 이동한다.Clone or Download를 클릭하고 URL을 복사한다. 구름IDE의 터미널에 복사한 clone 정보에서 “.git”를 삭제하고 hexo-theme-icarus도 hexoblog로 이름을 변경한다. 12git clone https://github.com/ppoffice/hexoblog npm install 좌측 폴더에서 hexoblog/themes/_config.yml의 파일을 열고 Extension으로 이동해서 theme의 landscape를 hexoblog로 변경한다. 1theme: hexoblog hexo server의 port를 open한다. port 확인은 프로젝트 -&gt; 실행 URL과 포트에서 확인 가능 12root@goorm:/workspace/blog/hexoblog/themes# hexo server -p 3000 hexo plug-in 1Code Block","link":"/2020/05/11/blog/"},{"title":"github pages 활용하기","text":"새로운 Repositories를 생성한다. Repositories의 이름은 URL을 생성하는 기준이다. 사용자ID.github.io를 추천한다. (참조 csbcp.github.io) github의 url을 복사하고 _config.yml의 # Deployment로 이동한다. type, repo, branch를 등록한다. 1234deploy: type: git repo: https://github.com/csbcp/csbcp.github.io branch: master github에 deploy 이전에 필요한 패키지를 설치한다. 1npm install hexo-deployer-git --save github에 파일을 올릴때에는 정적파일 형태로 deploy를 해야하므로 generate를 실행한다. 1hexo generate deploy에 필요한 정보를 설정한다. 123git config --global user.email \"charles\" global user.name \"charles\" git config --global user.email \"charles@uangel.com\" github에 deploy 한다. 1root@goorm:/workspace/blog/hexoblog/themes# hexo deploy 12Tip일정시간 hexo IDE를 이용하지 않으면 접속이 끊어진다. 이럴때는 터미널탭의 refresh 이미지를 클릭하면 재접속된다.","link":"/2020/05/11/hexo-using/"},{"title":"Jasper Studio 메뉴얼 (v0.1)","text":"Jasper Studio1. Jasper Studio 설치JasperSoft 사이트에 접속해서 파일을 다운로드한다.JasperSoft 사이트에서 User Guide를 제공하고 있으니궁금한 사항은 참고바란다. 12$ 기본 설정 방법JasperSoft Download (https://community.jaspersoft.com/project/jaspersoft-studio/releases) 2. Oracle 설정JasperSoft의 좌측메뉴에서 Data Adapters의 마우스 오른쪽을 클릭해서 Create Data Adapters를 클릭한다. Database JDBC Connect을 선택하고 Next를 클릭한다. Oracle 접속정보를 등록한다. JDBC Url, Username, Password는 접속하는 사이트에 맞게 설정하고 하단에 Test를 클릭한다. 123456$ 오라클 기본 설정 정보Name:Charles DBJDBC Driver:oracle.jdbc.driver.OracleDriverJDBC Url:jdbc:oracle:thin:@//127.0.0.1:1521/CharlesUsername:charlesPassword:xxxxxx Data Adapter Wizard 하단의 Driver Classpath로 이동하고 Add를 클릭해서 Oracle JDBC Driver 파일의 위치를 설정한다. Oracle JDBC Driver Download Successful 팝업 메시지가 보이면 Finish를 클릭해서 DB 접속을 마무리한다. 3. Server 접속 정보 설정JasperSoft의 좌측메뉴에서 Servers의 마우스 오른쪽을 클릭해서 Create JasperReports Server Connection를 클릭한다. JasperReports Server 접속정보를 등록한다 TIBCO Jaspersoft Studio User Guide. Name, URL, User, Password는 접속하는 서버의 정보를 입력하고 하단에 Test를 클릭한다. 12345$ JasperReports Server 기본 설정 정보Name:JasperReports Server ProURL:http://localhost:8080/jasperserver-pro/Username:charlesPassword:xxxxxx Successful 팝업 메시지가 보이면 Finish를 클릭해서 jasperReports Server 설정을 마무리한다. 4. Repository 생성Source를 저장 할 폴더를 생성한다. 프로젝트를 수행하는 경우 소스 관리를 위해서 git에 Repositories를 생성해서 진행하는것을 권고한다. 123$ Source 폴더 생성$ git에 Repositories 생성$ Source 폴더에서 git clone 수행 Source Import 진행 1234JasperSoft -&gt; File -&gt; Import 클릭General -&gt; Existing Project into Workspace 선택 이후 Next 클릭Browe..를 클릭해서 생성한 Source 폴더 연결Finish 클릭","link":"/2020/05/11/jasper-studio/"},{"title":"jasper-coffee","text":"Jasper Report 실습JasperSoft studio를 이용해서 간단한 샘플 보고서를 만든다. 12$ file -&gt; new -&gt; jasper report -&gt; Invoice를 선택 이후 next 클릭$ 새로운 보고서를 저장할 폴더 및 파일 이름 입력 이후 next 클릭 보고서는 기본적으로 Title, Column Header, Detail 1, Last Page Footer의 Band로 구성된다. 1234$ Title : 보고서의 첫페이지에 출력되는 밴드이다. (예:회사이름, 회사주소, 출력일자, etc)$ Column Header : Detail 1에 표시되는 데이터의 이름을 밴드이다. (예:고객명, 고객정보, 고객주소, etc)$ Detail 1 : 데이터를 출력하는 밴드이다. (예: 철수, 남자, 대한민군, etc)$ Last Page Footer : 보고서의 가장 마지막에 출력되는 밴드이다. (예: 안내문구, 보고서페이지, etc) 기본적인 Title 구성 한 후 보고서에 출력할 데이터를 DB에서 추출한다. 123$ 우측에 Dataset_and_Query_Dialog 아이콘을 클릭한다.$ 데이터를 추출한 SQL Query를 작성한다. $ 별도의 SQL Tool을 이용하여 1차 Query에 대한 검증을 완료하고 진행하는것을 추천한다. Dataset and Query Diaglog를 이용하여 데이터 추출하기 12345$ 1. 접속할 DB를 선택한다.$ 2. SQL Query를 작성한다.$ 3. Read Fields 버튼을 클릭한다.$ 4. 불필요한 필드를 삭제하고 순서를 조정한다.$ 5. Parameters 탭을 클릭한다 Query Parameters 추가하기 1234$ 좌측에 ```add``` 버튼을 클릭한다.$ 추가된 Parameter1을 더블클릭하면 파라메터 설정 팝업이 화면에 표시된다.$ Parameter Name을 포함하여 필요한 값을 선택 또는 입력하고 ```ok``` 버튼을 클릭한다.$ Data preview를 제공하고 있으며 ```Refresh Preview Data``` 버튼을 클릭하면 데이터를 화면에 출력한다. 보고서 데이터 출력하기 12345$ 1. Dataset and Query Diaglog에서 추출한 컬럼에 대한 정보가 표시된다.$ 2. 보고서 화면에 추가할 수 있는 Object가 표시된다.$ 3. 보고서 화면에서 Object를 선택하면 해당 Object에 대한 정보가 표시된다.$ 4. 보고서 디자인 과정 또는 마무리 이후에 보고서의 데이터를 확인 할 수 있는 Preview를 제공한다.$ 보고서의 모든 정보는 xml로 저장되면 필요하다면 직접 Source를 수정할 수 있다. 보고서 미리보기 12$ 1. 하단에 Preview화면은 좌측에 파라메터를 입력하는 화면, 우측에 보고서가 화면으로 구성되어있다.$ 2. 파라메터를 입력하고 위쪽에 실행버튼을 클릭하면 보고서가 화면에 출력된다.","link":"/2020/05/12/jasper-invoice/"},{"title":"Report File Publishing","text":"Jasper Report 파일 서버에 업로드12생성한 보고서를 Open합니다.메뉴(Project -&gt; Public the file on JasperReports Server를 클릭하거나 우측 상단에 [publish report button](publish-report-button.png)을 클릭합니다. 12345생성된 서버를 클릭하고 Public으로 이동한다.보고서 파일을 관리할 폴더를 선택하고 적당한 Unit Label, Name을 입력하고 Next를 클릭한다.Server에 Publishing될 정보가 표시된다. 참고 : [TIBCO Jaspersoft Studio User Guide](https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v611/publishing-report-jasperreports-server)","link":"/2020/05/14/jasper-upload/"},{"title":"Python 가상환경에서 오라클 접속하기","text":"Python 가상환경에서 오라클 접속하기 터미널에서 가상환경을 생성한다.$ python3 -m venv p_oracle 가상환경을 활성화한다.$ source p_oracle-env/bin/activate command에서 code를 입력하고 code을 실행한다.$ code cx_Oracle을 설치한다. 여기서 중요한 부분이 python이 아니고 python3로 설치를 해야한다.cx_Oracle(참조 : https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html#installing-cx-oracle-on-macos) 페이지를 확인하면 “python -m pip install cx_Oracle –upgrade”을 실행하라고 되어 있으나 .py를 실행하면 ModuleNotFoundError: No module named ‘cx_Oracle’ 메시지가 계속해서 출력된다… 그래서 터미널에서 python을 실행하고 import cx_Oracle을 실행하니 실행이되고 터미널에서 python3을 실행하고 import cx_Oracle을 실행하지 모듈을 못 찾는다는 오류가 발생했다. 이 경우 기존에 설치된 cx_Oracle을 uninstall을 수행하고 아래와 같이 실행하면된다. “sudo python -m pip uninstall cx_Oracle”$ python3 -m pip install cx_Oracle 아래와 같이 코드를 입력하고 실행한다. 123456789 from __future__ import print_functionimport cx_Oracleimport db_configcon = cx_Oracle.connect(\"'cbsadm\", \"'uangel123\", \"10.0.125.9/MTCCBS\", encoding=\"UTF-8\")print(\"Database version:\", con.version) “cx_Oracle.DatabaseError: ORA-24454: client host name is not set” 위와 같은 오류가 발생하면 /etc/hosts에 호스트가 등록되어 있는지 확인한다. 만약 등록되어 있지 않다면 호스트를 등록한다. “sudo /bin/bash -c “echo ‘127.0.1.1 ${HOSTNAME}’ &gt;&gt; /etc/hosts” 1","link":"/2020/05/13/p_oracle/"},{"title":"오라클 소스 암호화하기","text":"Oracle Wrap Utility를 이용해서 소스 암호화하기우선 소스르 암호화 하는 경우 원본을 잘 관리해야하며 원본이 분실 되었을 경우 복구는 할 수 없음을 유의해야 한다.소스 암호화는 오라클에서 제공하는 Oracle Wrap Utility를 이용한다. Connect Oracle Server /home/oracle/base/12.2.0/db/bin 디렉토리로 이동. 오라클 설치 디렉토리는 조금 다를 수 있습니다. wrap iname=[file] oname=[file]첫번째 인수는 원본 파일 두번째 인수를 생성할 파일이다. “wrap iname=CRYPTO.pks oname=CRYPTO.wrp” 12345678 [oracle@/home/oracle/base/12.2.0/db/bin]$ wrap iname=CRYPTO.pks oname=CRYPTO.wrpPL/SQL Wrapper: Release 12.2.0.1.0- 64bit Production on Wed Jun 03 12:51:48 2020Copyright (c) 1993, 2009, Oracle. All rights reserved.Processing CRYPTO.pks to CRYPTO.wrp SQL Developer 또는 SQL 관리툴을 이용하여 CRYPTO.wrp 파일을 오픈하고 컴파일한다. 개인 PC에서 wrap 파일을 생성 할 경우 오라클 사이트에서 오라클 DB을 설치하면 /bin 디렉토리에 wrap 파일이 설치된다.(오라클 클라이언트 아님…) 3번과 같은 방법으로 처리한다. Oracle DBMS_DDL 이용해서 소스 암호화하기DBMS_DDL을 이용해서 암호화 하는 경우는 Dynamic Wrap을 사용한다. 새로운 Procedure를 생성한다. l_source와 l_wrap을 변수를 선언한다. l_source에 wrap 할 procedure를 넣습니다. SYS.DBMS_DDL.WRAP(ddl =&gt; l_source)를 이용해서 wrap으로 변환합니다. l_wrap를 DBMS_OUTPUT으로 출력하고 출력된 내용을 컴파일합니다.123456789101112131415161718192021222324252627282930313233 CREATE OR REPLACE PROCEDURE sp_wrap IS/****************************************************************************** NAME: sp_wrap PURPOSE: REVISIONS: Ver Date Author Description --------- ---------- --------------- ------------------------------------ 1.0 2020/06/03 charles 1. Created this procedure. NOTES: Automatically available Auto Replace Keywords: Object Name: sp_wrap Sysdate: 2020/06/03 Date and Time: 2020/06/03, 오후 3:13:02, and 2020/06/03 오후 3:13:02 Username: charles (set in TOAD Options, Procedure Editor) Table Name: (set in the \"New PL/SQL Object\" dialog)******************************************************************************/ l_source VARCHAR2(32767); l_wrap VARCHAR2(32767);BEGIN l_source := 'CREATE OR REPLACE FUNCTION get_date_string RETURN VARCHAR2 AS' || 'BEGIN ' || 'RETURN TO_CHAR(SYSDATE, ''DD-MON-YYYY''); ' || 'END get_date_string;'; l_wrap := SYS.DBMS_DDL.WRAP(ddl =&gt; l_source); DBMS_OUTPUT.put_line(l_wrap);END sp_wrap;/","link":"/2020/06/03/oracle_wrap/"},{"title":"1. Python 환경설정","text":"개발 가상 환경 설정 테스트 코드개발 환경 설정 (MAC)일단 Python을 이용해서 개발을 진행하기 위해서 필요한 파일을 설치하겠습니다.총 5개의 파트로 구분했으며 설치는 별로 어렵지 않습니다.개발 환경은 MAC으로 진행하겠습니다. 123451. Python 설치2. Editor 설치 (Visual Studio Code)3. Virtual Environment 설정 (Venv)4. editor plug-in 설치5. test package 설치 1. Python 설치123456789- 우선 Python 설치파일을 (https://www.python.org/downloads/)하세요. - 다운로드 한 패키지 파일을 실행해서 설치하시면 됩니다. 설치과정은 어렵지 않아서 패스. - 이제 정상적으로 설치가 잘 되었는지 확인하겠습니다.- 우선 Terminal을 실행하고 Prompt에 python3을 입력하고 실행했을때 아래와 같은 메시지가 화면에 보이면 OK. Python 3.7.3 (default, Apr 7 2020, 14:06:47)[Clang 11.0.3 (clang-1103.0.32.59)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt;- 참고로 python을 입력하고 실행하면 2.xx 버전이 실행된다. MAC은 기본적으로 2.xx가 설치되어 있습니다.. 2. Editor 설치 (Visual Studio Code)1234- Python은 개발은 본인이 선호하는 툴을 사용해도 괜찮고 원하는 Editor를 사용해도 무방합니다. (Atom, PyCharm, etc)- Visual Studio Code 설치 파일 [다운로드](https://visualstudio.microsoft.com/ko/downloads/)하세요. - 다운로드 한 패키지 파일을 설치한다. 설치과정이 어렵지 않아서 추가 설명을 하지 않는다. - 정상적으로 설치가 되었다면 Terminal을 실행하고 Prompt에 code를 입력하면 Visual Studio Code가 실행된다 3. Virtual Environment 설정 (Venv)12345678- 가상환경을 이용하는 이유는 사이트마다 버전을 다르게 개발했을 경우 사이트의 유지보수가 힘들기 때문에 가능하면 가상환경을 구축해서 필요한 패키지를 설치하고 개발하는것을 권고한다.- 터미널을 실행하고 작업 디렉토리를 생성하고 아래의 명령어를 실행한다. 참고로 현재 위치에서 만들어진다. [참고](https://docs.python.org/3/tutorial/venv.html?highlight=virtual \"Python Doc\") $ python -m venu p_study- 생성된 디렉토리를 확인하고 아래 명령어를 이용해서 활성화한다. $ source ./bin/activate- Prompt가 가상환경을 바뀐것을 확인할 수 있다. \"$ (p_study) \" 작업 과정에서 오류가 발생한 경우 생성된 폴더를 삭제하고 가상환경을 재실행한다.- 가상환경이 Active 된 이후 Prompt에 code를 입력해서 Editor를 실행한다. 4. editor plug-in 설치12345678910- 가상환경이 설치된 위치에서 pin list를 실행하면 현재 설치된 pip 목록을 확인할 수 있다. 가상환경을 구축해서 필요한 패키지를 설치하고 개발하는것을 권고한다.- 터미널을 실행하고 작업 디렉토리를 생성하고 아래의 명령어를 실행한다. 참고로 현재 위치에서 만들어진다. [참고](https://docs.python.org/3/tutorial/venv.html?highlight=virtual \"Python Doc\") $ python3 -m venv tutorial-env- 생성된 디렉토리를 확인하고 아래 명령어를 이용해서 활성화한다. $ source ./bin/activate- Prompt가 가상환경을 바뀐것을 확인할 수 있다. \"$ (tutorial-env) \" 작업 과정에서 오류가 발생한 경우 생성된 폴더를 삭제하고 가상환경을 재실행한다. $ (tutorial-env) - 가상환경이 Active된 이후 Prompt에 \"code\"를 입력해서 Editor를 실행한다. To be continued… pip install pendulumpip install pytest","link":"/2020/05/13/python_ch_01/"},{"title":"3. Python Class &amp; Method","text":"Python의 개발 및 이해를 돕기 위해서 코드를 시각화하고 실시간 도움말 얻을 수 있는 Site가 있다.Python Tutor (created by Philip Guo)는 사람들이 프로그래밍 학습에 대한 근본적인 장벽을 극복하도록 도와줍니다.컴퓨터가 각 코드의 줄을 실행할 때 발생하는 상황을 이해 할 수 있도록 시각화해서 표시합니다. Class 기반 개발객체 지향 프로그래밍(OOP)의 장점은 코드의 재사용, 코드 중복 방지 등의 장점이 있다.과거 규모가 큰 프로젝트(프로그램)은 함수의 중심으로 개발이 되었으며 함수 중심의 개발을 진행하다보니 데이터가 방대해지면서 복잡해졌다.그래서 클래스 중심으로 변화가 되면서 함수 중심이 아니고 데이터 중심으로 구성요소들의 객체를 관리했다.물론 정답은 없으며 프로젝트의 상황에 따라서 객체지향 또는 클래스 기반으로 개발을 진행하면 된다. 일반적인 코딩 12345678910111213141516171819202122차량 1, 2, 3car_company_1 = 'Ferrari'car_detail_1 = [ {'color' : 'White'}, {'hoursepower' : 4000}, {'price' : 8000}]car_company_2 = 'BMW'car_detail_2 = [ {'color' : 'Black'}, {'hoursepower' : 270}, {'price' : 5000}]car_company_3 = 'Audi'car_detail_3 = [ {'color' : 'Silver'}, {'hoursepower' : 300}, {'price' : 6000}] 리스트 구조 크기가 가변적이고, 어떤 원소 타입이던 저장할 수 있다는 장점이 있으나 관리가 불편하고 인덱스로 접근 시 실수 가능성 증가하며 삭제가 불편하다. 또한 많은 리소스를 필요로 한다.리스트를 만들 때는 대괄호([ ])로 감싸 주고 각 Value는 쉼표(,)로 구분해 준다. 123456car_company_list = ['Ferrari', 'BMW', 'Audi']car_detail_list = [ {'color' : 'White', 'hoursepower' : 4000, 'price' : 8000}, {'color' : 'Black', 'hoursepower' : 270, 'price' : 5000}, {'color' : 'Silver', 'hoursepower' : 300, 'price' : 6000}] 자동차 회사 삭제clear() , pop() and remove()는 list의 methods이다.del을 사용해서 요소를 삭제 할 수 있으며 index를 이용해서 특정 요소를 삭제할 수 있습니다. 12del car_company_list[1]del car_detail_list[1] 딕셔너리 구조리스트나 튜플처럼 순차적으로(sequential) 해당 Value를 구하지 않고 Key를 통해 Value의 구조로 구성되며코드의 반복 지속 및 중첩 문제 그리고 키 조회 예외 처리등이 가능한다.딕셔너리는 { }(중괄호)안에 키: 값 형식으로 저장하며 각 키와 Value는 ,(콤마)로 구분된다 12345cars_dicts = [ {'car_company':'Ferrari', 'car_detail': {'color' : 'White', 'hoursepower' : 4000, 'price' : 8000}}, {'car_company':'BMW', 'car_detail': {'color' : 'Black', 'hoursepower' : 270, 'price' : 5000}}, {'car_company':'Audi', 'car_detail': {'color' : 'Silver', 'hoursepower' : 300, 'price' : 6000}}] pop(‘key’, ‘default’)pop()은 맨 마지막 요소를 돌려주고 pop(x)는 리스트의 x번째 요소를 돌려주고 그 요소는 삭제한다. 12345678cars_dicts.pop()print(cars_dicts)cars_dicts.pop(1)print(cars_dicts)del cars_dicts[1]print(cars_dicts) 클래스 구조클래스란 얼음을 만드는 얼음틀(Class)과 그것을 이용해서 만든 얼음(Object)이다.클래스는 똑같은 무엇인가를 계속해서 만들어 낼 수 있는 설계 도면이고(얼음틀), 객체(object)란 클래스로 만든 피조물(얼음)을 뜻한다.클래스로 만든 객체는 고유한 성격을 가지며 얼음틀로 만든 얼음이 깨지더라고 다른 얼음에는 아무 영향이 없는 것과 마찬가지로 동일한 클래스로 만든 객체들은 서로 전혀 영향을 주지 않는다.클래스는 구조 설계 후 재사용성 증가하고 반복되는 코드를 최소화하며 메소드를 활용할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940class Car(): \"\"\" Car class Author : Charles Date : 2020.05.07 \"\"\" # self 의미 : Instance Method def __init__(self, company, details): self._company = company self._details = details # This method returns the string representation of the object def __str__(self): return 'str : {} - {}'.format(self._company, self._details) # 개발자 레벨에서 엄격하게 데이터를 보고자 할 경우 def __repr__(self): return 'repr : {} - {}'.format(self._company, self._details) def __reduce__(self): pass # @Class Method (Cls = Car) # @Class 변수를 핸들링 하는 경우 @classmethod를 이용하는것을 권장. @classmethod def raise_price(cls, per): if per &lt;= 1: print('Price enter 1 or more') return cls.price_per_raise = per print('Succeed! Price increased') # @Static Method # @Static Method는 기본적으로 인자를 받지 않는다. 유연한 Method를 정의할때에 사용한다. @staticmethod def is_bmw(inst): if inst._company == 'BMW': return 'OK! This car is {}'.format(inst._company) return 'Sorry! This car is not {}'.format(inst._company) Difference between str and repr? 12345678__repr__ is for developers, __str__ is for customers.&gt;&gt;&gt; import datetime &gt;&gt;&gt; today = datetime.datetime.now() &gt;&gt;&gt; str(today) '2012-03-14 09:21:58.130922' &gt;&gt;&gt; repr(today) 'datetime.datetime(2012, 3, 14, 9, 21, 58, 130922)' 3개의 객체를 생성하고 객체에 대한 정보를 확인한다. 1234567891011121314car1 = Car('Ferrari', {'color' : 'White', 'hoursepower' : 4000, 'price' : 8000}) car2 = Car('BMW', {'color' : 'Black', 'hoursepower' : 270, 'price' : 5000}) car3 = Car('Audi', {'color' : 'Silver', 'hoursepower' : 300, 'price' : 6000}) print(car1) print(car2) print(car3)$ 모든 모듈의 특별한 속성은 __dict__입니다.print(car1.__dict__) print(car2.__dict__) print(car3.__dict__) print(dir(car1)) 각각의 객체는 고유한 ID가 존재한다. print(id(car1))print(id(car2))print(id(car3)) print(car1._company == car2._company) # Comapare Valueprint(car1._company is car2._company) # Instance 비교 (ID) dir &amp; dict 확인. dir은 포괄적인 정보를 표시 123456789101112131415161718print(dir(car1))print(dir(car2))print(car1.__doc__)car1.detail_info()print(Car.detail_info(car1))car2.detail_info()print(Car.detail_info(car2))print(car1.__class__, car2.__class__)print(id(car1.__class__), id(car2.__class__)) # 부모는 갔다.print(car1.get_price())print(Car.get_price(car1))print(car1.get_price_culc())print(Car.get_price_culc(car1)) 가격 인상(클래스 메소드 사용) 1Car.raise_price(1.86) 가격정보(인상후) 12345print(car1.get_price_culc())print(car2.get_price_culc())print(Car.is_bmw(car1))print(Car.is_bmw(car2))","link":"/2020/05/15/python_ch_03/"},{"title":"5. Python Sequence","text":"Python SequencePython Sequence는 서로 다른 자료형과 단일 자료형으로 구분 할 수 있다. 서로 다른 자료형 : Container[list, tuple, collections, deque]단일 자료형 : flat[str, bytes, bytearray, array, memorryview]또한 가변형과 불변형으로도 구분 할 수 있다.가변형 : list, bytearray, array, memorryview, deque불변형 : tuple, str, bytes 지능형 리스트(Comprehending Lists)12345678910111213141516chars = '+_)(*&amp;%$#@!) code_list1 = []for s in chars: #유니코드 리스트 code_list1.append(ord(s))print(code_lists1)$ [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 126, 41]code_list2 = [ord(s) for s in chars]print(code_lists2)$ [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 126, 41] Comprehending Lists + Map, Filtermap(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다. map은 입력받은 자료형의 각 요소를 함수 f가 수행한 결과를 묶어서 돌려주는 함수이다. filter 함수는 첫 번째 인수로 함수 이름을, 두 번째 인수로 그 함수에 차례로 들어갈 반복 가능한 자료형을 받는다. 그리고 두 번째 인수인 반복 가능한 자료형 요소가 첫 번째 인수인 함수에 입력되었을 때 반환 값이 참인 것만 묶어서(걸러 내서) 돌려준다. 속도 약간 우세1234567code_list3 = [ord(s) for s in chars if ord(s) &gt; 40]code_list4 = list(filter(lambda x : x &gt; 40, map(ord, chars)))print(code_list3)print(code_list4)print([chr(s) for s in code_list1]) Generator 생성1import array Generator : 한 번에 한 개의 항목을 생성(메모리 유지X)1tuple_g = (ord(s) for s in chars) Array123456array_g = array.array('I', (ord(s) for s in chars))print(type(tuple_g))print(next(tuple_g))print(type(array_g))print(array_g.tolist())","link":"/2020/05/18/python_ch_05/"},{"title":"4. Sepcial Method","text":"Special Method(Magic Method)Python의 가장 핵심은 순서(Sequence), 반복(Iterator), 함수(Function), 클래스(Class)이다.Special Method란 Class안에 정의할 수 있는 특별한(Built in) Method이다. In Python, special methods are a set of predefined methods you can use to enrich your classes. They are easy to recognize because they start and end with double underscores, for example init or str. To Be Continued… 1","link":"/2020/05/15/python_ch_04/"},{"title":"5-2. Hash Table","text":"Hash TableHash Table은 Key에 Value를 저장하는 구조입니다.Index Value가 Data의 Key Value 역활을 하므로 데이터를 보다 빠르게 접근할 수 있습니다.또한 Key Value의 연산 결과에 따른 직접 접근이 가능한 구조입니다. Dict 구조Dict 요소를 접근하려면 대괄호에 키와 함께 사용하여 값을 얻을 수 있습니다. 1dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'} Key를 이용하여 dictionary에 접근해 보겠습니다. 12print (\"dict['Name']: \", dict['Name'])print (\"dict['Age']: \", dict['Age']) 위 코드를 실행하면 다음과 같은 결과가 나타납니다. 12$ dict['Name']: Zara$ dict['Age']: 7 setdefault()Dict에 Key와 Value 저장하기 123456789source = (('k1', 'val1'), ('k1', 'val2'), ('k2', 'val3'), ('k2', 'val4'), ('k2', 'val5'), )new_dict1 = {}new_dict2 = {} Not use setdefault() 12345for k, v in source: if k in new_dict1: new_dict1[k].append(v) else: new_dict1[k] = [v] Use setdefault() 12for k, v in source: new_dict2.setdefault(k, []).append(v) 위 코드를 실행하면 다음과 같은 결과를 확인 할 수 있습니다. 12$ new_dict1 : {'k1': ['val1', 'val2'], 'k2': ['val3', 'val4', 'val5']}$$ new_dict2 : {'k1': ['val1', 'val2'], 'k2': ['val3', 'val4', 'val5']}","link":"/2020/05/27/python_ch_05_2/"},{"title":"6-1. 일급 함수 (일급 객체)","text":"기본 특정코드를 간결하게 작성할 수 있으며, 개발시간을 단축할 수 있으며, 순수함수를 지향하며 동시에 여러 스레드에서 문제 없이 동작하는 프로그램을 쉽게 작성한다. 런타임 초기화 변수 할당 가능 변수 인수 전달 가능 함수 결과 반환 가능(return) Immutable파이썬의 모든 것은 객체입니다. 그리고 파이썬을 처음 접하는 모든 사람들이 빨리 배워야하는 것은 파이썬의 모든 객체는 변경 가능 하거나 변경 불가능 하다는 것 입니다. 파이썬의 모든 것이 객체이므로 모든 변수는 객체 인스턴스를 보유합니다. 객체가 시작되면 고유 한 객체 ID가 할당됩니다. 유형은 런타임에 정의되며 일단 설정된 후에는 변경할 수 없지만 변경 가능한 경우 상태를 변경할 수 있습니다. 간단히 말해서, 변경 가능한 객체는 생성 된 후에 변경 될 수 있으며 변경 불가능한 객체 는 변경할 수 없습니다. (int, float, bool, str, tuple, unicode)와 같은 내장 유형의 객체는 변경할 수 없습니다. (list, set, dict)와 같은 내장 유형의 객체는 변경 가능합니다. 커스텀 클래스는 일반적으로 변경 가능합니다. 클래스에서 불변성을 시뮬레이션하려면 속성 설정 및 삭제를 재정 의하여 예외를 발생시켜야합니다. 참고 자 그럼 mutable과 immutable을 어떻게 구분할까요?우리는 ‘ID’와 ‘TYPE’으로 확인 할 수 있습니다. ID &amp; Typebuilt-in 함수인 id()는 객체의 ID를 정수로 반환합니다. 물론 ID는 객체의 메모리 주소에 해당하지만 파이썬의 버전 및 플랫폼에 따라서 다른 값을 표현합니다. 우리는 “is”를 이용해서 확인 할 수 있습니다. 1234567891011121314151617181920# Example 1 x = \"Holberton\" y = \"Holberton\" print(id(x)) print(id(y)) $ 140135852055856 $ 140135852055856# comparing the types print(x is y) $ True # Example 2 a = 50 print(type(a)) $ &lt;class: ‘int’&gt; b = \"Holberton\" print(type(b)) $ &lt;class: 'string'&gt; 두 함수를 사용하여 다양한 유형의 객체가 변수와 연결되는 방식과 객체를 변경하는 방법을 확인할 수 있습니다. Mutable and Immutable Objects앞에서 설명한 것처럼 가변 객체는 상태나 내용을 변경할 수 있으며 불변 객체는 변경할 수 없습니다. Immutable Dict12345678910111213141516# 새로운 객체를 생성한다.d = {'key':'value'}# Read/Write# 객체에 값을 추가하면 정상적으로 값이 추가되는것을 확인 할 수 있다.d['key2'] = 'value2'print(d)$ {'key': 'value', 'key2': 'value2'}# Read Only# MappingProxyType을 이용해서 새로운 객체를 할당하고 값을 변경하면 오류가 발생하는것을 확인 할 수 있다. 많은 개발자들은 통상적으로 \"frozen\"이라는 변수 이름을 사용하고 그 변수는 값을 변경 할 수 없는 immutable이라고 생각하면 된다.d_frozen = MappingProxyType(d)d_frozen['Key2'] = 'value2'# TypeError: 'mappingproxy' object does not support item assignment","link":"/2020/06/02/python_ch_05_3/"},{"title":"5-1. sort vs sorted","text":"Sort vs SortedSorted : 데이터 정렬 후 새로운 리스트로 반환합니다. 이는 여러 번 정렬할 때 유용합니다 (예를 들어, 부서별로 정렬한 후에 급여 등급별로 정렬하기).Sort : 데이터 정렬 후 객체를 변환한다. 실습을 위한 List 객체를 만들겠습니다. 1f_list = ['orange', 'apple', 'mango', 'papaya', 'lemon', 'strawberry', 'coconut'] Sorted1234567891011121314151617181920정렬된 리스트와 원본을 비교하려면 f_list를 넣어주면 쉽게 확인이 가능합니다.정렬된 리스트 데이터를 확인 할 수 있으며 원본 데이터는 변화가 없음을 확인 할 수 있습니다.print('sorted - ', sorted(f_list), f_list)$ sorted - ['apple', 'coconut', 'lemon', 'mango', 'orange', 'papaya', 'strawberry'] ['orange', 'apple', 'mango', 'papaya', 'lemon', 'strawberry', 'coconut']정렬 이후 reverse를 할 경우 \"reverse=True\"로 정의한다. reverse의 기본값은 False이다.print('sorted_reverse -', sorted(f_list, reverse=True))$ sorted_reverse - ['strawberry', 'papaya', 'orange', 'mango', 'lemon', 'coconut', 'apple']데이터 길이로도 정렬할 수 있다.print('sorted_len -', sorted(f_list, key=len))$ sorted_len - ['apple', 'mango', 'lemon', 'orange', 'papaya', 'coconut', 'strawberry']lambda도 이용할 수 있으며 key=lambda x: x[-1]는 -1이므로 마지막 글자를 기준으로 정렬된다.print('sorted_lambda -', sorted(f_list, key=lambda x: x[-1]))$ sorted_lambda - ['papaya', 'orange', 'apple', 'lemon', 'mango', 'coconut', 'strawberry']마지막 글자를 reverse 할 수도 있다.print('sorted_lambda_reverse -', sorted(f_list, key=lambda x: x[-1], reverse=True))$ sorted_lambda_reverse - ['strawberry', 'coconut', 'mango', 'lemon', 'orange', 'apple', 'papaya'] Sort12345678910111213141516171819데이터 정렬 후 원본 객체의 변화를 확인하겠습니다. sort는 결과값으로 반환 활 객체가 없기때문에 none이 표시되고 원본 데이터가 변경된 것을 확인 할 수 있습니다.print('sort -', f_list.sort(), f_list)$ sort - None ['apple', 'coconut', 'lemon', 'mango', 'orange', 'papaya', 'strawberry']print('sort_reverse -', f_list.sort(reverse=True), f_list)$ sort_reverse - None ['strawberry', 'papaya', 'orange', 'mango', 'lemon', 'coconut', 'apprint('sort_len -', f_list.sort(key=len), f_list)sort_len - None ['mango', 'lemon', 'apple', 'papaya', 'orange', 'coconut', 'strawberry']print('sort_lambda -', f_list.sort(key=lambda x: x[-1]), f_list)sort_lambda - None ['papaya', 'apple', 'orange', 'lemon', 'mango', 'coconut', 'strawberry']print('sort_lambda_reverse -', f_list.sort(key=lambda x: x[-1], reverse=True), f_list)ple']sort_lambda_reverse - None ['strawberry', 'coconut', 'mango', 'lemon', 'apple', 'orange', 'papaya']","link":"/2020/05/26/python_ch_05_1/"},{"title":"5-3. Immutable Dict 생성","text":"참고 Immutable파이썬의 모든 것은 객체입니다. 그리고 파이썬을 처음 접하는 모든 사람들이 빨리 배워야하는 것은 파이썬의 모든 객체는 변경 가능 하거나 변경 불가능 하다는 것 입니다. 파이썬의 모든 것이 객체이므로 모든 변수는 객체 인스턴스를 보유합니다. 객체가 시작되면 고유 한 객체 ID가 할당됩니다. 유형은 런타임에 정의되며 일단 설정된 후에는 변경할 수 없지만 변경 가능한 경우 상태를 변경할 수 있습니다. 간단히 말해서, 변경 가능한 객체는 생성 된 후에 변경 될 수 있으며 변경 불가능한 객체 는 변경할 수 없습니다. (int, float, bool, str, tuple, unicode)와 같은 내장 유형의 객체는 변경할 수 없습니다. (list, set, dict)와 같은 내장 유형의 객체는 변경 가능합니다. 커스텀 클래스는 일반적으로 변경 가능합니다. 클래스에서 불변성을 시뮬레이션하려면 속성 설정 및 삭제를 재정 의하여 예외를 발생시켜야합니다. 참고 자 그럼 mutable과 immutable을 어떻게 구분할까요?우리는 ‘ID’와 ‘TYPE’으로 확인 할 수 있습니다. ID &amp; Typebuilt-in 함수인 id()는 객체의 ID를 정수로 반환합니다. 물론 ID는 객체의 메모리 주소에 해당하지만 파이썬의 버전 및 플랫폼에 따라서 다른 값을 표현합니다. 우리는 “is”를 이용해서 확인 할 수 있습니다. 1234567891011121314151617181920# Example 1 x = \"Holberton\" y = \"Holberton\" print(id(x)) print(id(y)) $ 140135852055856 $ 140135852055856# comparing the types print(x is y) $ True # Example 2 a = 50 print(type(a)) $ &lt;class: ‘int’&gt; b = \"Holberton\" print(type(b)) $ &lt;class: 'string'&gt; 두 함수를 사용하여 다양한 유형의 객체가 변수와 연결되는 방식과 객체를 변경하는 방법을 확인할 수 있습니다. Mutable and Immutable Objects앞에서 설명한 것처럼 가변 객체는 상태나 내용을 변경할 수 있으며 불변 객체는 변경할 수 없습니다. Immutable Dict12345678910111213141516# 새로운 객체를 생성한다.d = {'key':'value'}# Read/Write# 객체에 값을 추가하면 정상적으로 값이 추가되는것을 확인 할 수 있다.d['key2'] = 'value2'print(d)$ {'key': 'value', 'key2': 'value2'}# Read Only# MappingProxyType을 이용해서 새로운 객체를 할당하고 값을 변경하면 오류가 발생하는것을 확인 할 수 있다. 많은 개발자들은 통상적으로 \"frozen\"이라는 변수 이름을 사용하고 그 변수는 값을 변경 할 수 없는 immutable이라고 생각하면 된다.d_frozen = MappingProxyType(d)d_frozen['Key2'] = 'value2'# TypeError: 'mappingproxy' object does not support item assignment","link":"/2020/05/28/python_ch_05_01/"},{"title":"2. Python 가상환경 테스트","text":"가상 환경 테스트1. 가상환경에서 “code” 실행1234567891011121314151617181920가상환경이 Active 상태에서 \"pip list\"를 명령어를 실행하면 기본적으로 아무것도 설치되어 있지 않다. Package Version ---------- ------- pip 19.0.3 setuptools 40.8.0 You are using pip version 19.0.3, however version 20.1 is available. You should consider upgrading via the 'pip install --upgrade pip' command.pip install --upgrade pip를 실행한다.Python이 정상적으로 설치가 되었는지 확인하기 위해서 몇가지 확인작업을 진행한다.Terminal에서 pip install pendulum을 실행한다. (Python의 시간과 날짜를 쉽게 만들도록 해 준다)\"pip list\"를 명령어를 실행해서 정상적으로 패키지가 설치되었는지 확인한다. Package Version --------------- ------- pendulum 2.1.0 pip 20.1 python-dateutil 2.8.1 pytzdata 2019.3 setuptools 40.8.0 six 1.14.0가상환경이 Active된 이후 Prompt에 \"code\"를 입력해서 Editor를 실행한다. 2. 가상 환경 설정 테스트 Editor에서 아래의 코드를 입력하고 코드를 실행한다. pendulum 패키지 확인 참조 123456789101112131415import pendulumfrom datetime import datetimepst = pendulum.timezone('America/Los_Angeles')ist = pendulum.timezone('Asia/Seoul')# 타입 확인print(type(pst))# 타임존 시간 출력print('Current Date Time in PST =', datetime.now(pst))print('Current Date Time in IST =', datetime.now(ist))# 타입 확인print(type(ist)) Result 1234&lt;class 'pendulum.tz.timezone.Timezone'&gt;Current Date Time in PST = 2020-05-14 01:32:57.837594-07:00Current Date Time in IST = 2020-05-14 17:32:57.837676+09:00&lt;class 'pendulum.tz.timezone.Timezone'&gt;","link":"/2020/05/15/python_ch_02/"}],"tags":[{"name":"Jasper","slug":"Jasper","link":"/tags/Jasper/"},{"name":"Report","slug":"Report","link":"/tags/Report/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"Sequence","slug":"Sequence","link":"/tags/Sequence/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Sorted","slug":"Sorted","link":"/tags/Sorted/"},{"name":"Immutable","slug":"Immutable","link":"/tags/Immutable/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"일급함수","slug":"일급함수","link":"/tags/%EC%9D%BC%EA%B8%89%ED%95%A8%EC%88%98/"},{"name":"first-class","slug":"first-class","link":"/tags/first-class/"}],"categories":[{"name":"JasperSoft","slug":"JasperSoft","link":"/categories/JasperSoft/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"github.io blog","slug":"Hexo/github-io-blog","link":"/categories/Hexo/github-io-blog/"},{"name":"github pages 활용하기","slug":"Hexo/github-pages-활용하기","link":"/categories/Hexo/github-pages-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"name":"Jasper Studio 설치","slug":"JasperSoft/Jasper-Studio-설치","link":"/categories/JasperSoft/Jasper-Studio-%EC%84%A4%EC%B9%98/"},{"name":"Jasper Report 실습","slug":"JasperSoft/Jasper-Report-실습","link":"/categories/JasperSoft/Jasper-Report-%EC%8B%A4%EC%8A%B5/"},{"name":"Report 파일 서버에 올리기","slug":"JasperSoft/Report-파일-서버에-올리기","link":"/categories/JasperSoft/Report-%ED%8C%8C%EC%9D%BC-%EC%84%9C%EB%B2%84%EC%97%90-%EC%98%AC%EB%A6%AC%EA%B8%B0/"},{"name":"1. Python 환경설정","slug":"Python/1-Python-환경설정","link":"/categories/Python/1-Python-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"},{"name":"2. Python 가상환경 테스트","slug":"Python/2-Python-가상환경-테스트","link":"/categories/Python/2-Python-%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD-%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"3. Python Python Class &amp; Method","slug":"Python/3-Python-Python-Class-Method","link":"/categories/Python/3-Python-Python-Class-Method/"},{"name":"가상환경에서 오라클 접속하기","slug":"Python/가상환경에서-오라클-접속하기","link":"/categories/Python/%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0/"},{"name":"5. Python Sequence","slug":"Python/5-Python-Sequence","link":"/categories/Python/5-Python-Sequence/"},{"name":"4. Special Method(Magic Method)","slug":"Python/4-Special-Method-Magic-Method","link":"/categories/Python/4-Special-Method-Magic-Method/"},{"name":"sort vs sorted","slug":"Python/5-Python-Sequence/sort-vs-sorted","link":"/categories/Python/5-Python-Sequence/sort-vs-sorted/"},{"name":"Hash Table","slug":"Python/5-Python-Sequence/Hash-Table","link":"/categories/Python/5-Python-Sequence/Hash-Table/"},{"name":"Immutable Dict","slug":"Python/5-Python-Sequence/Immutable-Dict","link":"/categories/Python/5-Python-Sequence/Immutable-Dict/"},{"name":"Oracle","slug":"Oracle","link":"/categories/Oracle/"},{"name":"소스 암호화 하기","slug":"Oracle/소스-암호화-하기","link":"/categories/Oracle/%EC%86%8C%EC%8A%A4-%EC%95%94%ED%98%B8%ED%99%94-%ED%95%98%EA%B8%B0/"},{"name":"5. Python Function","slug":"Python/5-Python-Function","link":"/categories/Python/5-Python-Function/"},{"name":"기본 특징","slug":"Python/5-Python-Function/기본-특징","link":"/categories/Python/5-Python-Function/%EA%B8%B0%EB%B3%B8-%ED%8A%B9%EC%A7%95/"}]}